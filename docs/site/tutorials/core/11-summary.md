---
lang: en
title: 'Summary'
keywords: LoopBack 4.0, LoopBack 4
sidebar: lb4_sidebar
permalink: /doc/en/lb4/core-tutorial-part11.html
---

In the previous sections, we have explained how various features in LoopBack
core modules can be useful for our developers to build a scalable Node.js
application.

LoopBack can also be used as the framework to create microservices. The
[Twelve-Factor App](https://12factor.net) methodology is a methodology for
building software-as-a-service applications. This section shows how the criteria
of Twlve-Factor are satisfied by Node.js application powered by LoopBack.

### I. Codebase - One codebase tracked in revision control, many deploys

LoopBack application code can be committed to GitHub for the version control.

### II. Dependencies - Explicitly declare and isolate dependencies

[Dependency injection](https://loopback.io/doc/en/lb4/Dependency-injection.html)
can be used to keep the construction of dependencies of a class or function
separated from its behavior.

### III. Config - Store config in the environment

Context-based configuration and pluggable configuration resolver.

### IV. Backing services - Treat backing services as attached resources

Services/DataSources/...

### V. Build, release, run - Strictly separate build and run stages

npm scripts

### VI. Processes - Execute the app as one or more stateless processes

A LoopBack application can be deployed and run in a stateless Docker container.
A `Dockerfile` is generated by default when scaffolding a LoopBack application.

### VII. Port binding - Export services via port binding

HTTP/HTTPS server via configuration

### VIII. Concurrency - Scale out via the process model

### IX. Disposability - Maximize robustness with fast startup and graceful shutdown

Life cycle events and observers

### X. Dev/prod parity - Keep development, staging, and production as similar as possible

### XI. Logs Treat logs as event streams

### XII. Admin processes Run admin/management tasks as one-off processes
